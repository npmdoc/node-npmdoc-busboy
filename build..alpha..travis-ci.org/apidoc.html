<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/mscdex/busboy#readme"

    >busboy (v0.2.14)</a>
</h1>
<h4>A streaming parser for HTML form data for node.js</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.busboy">module busboy</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.busboy">
            function <span class="apidocSignatureSpan"></span>busboy
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.multipart">
            function <span class="apidocSignatureSpan">busboy.</span>multipart
            <span class="apidocSignatureSpan">(boy, cfg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.super_">
            function <span class="apidocSignatureSpan">busboy.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.urlencoded">
            function <span class="apidocSignatureSpan">busboy.</span>urlencoded
            <span class="apidocSignatureSpan">(boy, cfg)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">busboy.</span>encoding</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">busboy.</span>multipart.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">busboy.</span>urlencoded.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">busboy.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.busboy.encoding">module busboy.encoding</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.encoding.TextDecoder">
            function <span class="apidocSignatureSpan">busboy.encoding.</span>TextDecoder
            <span class="apidocSignatureSpan">(opt_encoding, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.encoding.TextEncoder">
            function <span class="apidocSignatureSpan">busboy.encoding.</span>TextEncoder
            <span class="apidocSignatureSpan">(opt_encoding, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.encoding.encodingExists">
            function <span class="apidocSignatureSpan">busboy.encoding.</span>encodingExists
            <span class="apidocSignatureSpan">(label)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.busboy.multipart">module busboy.multipart</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.multipart.multipart">
            function <span class="apidocSignatureSpan">busboy.</span>multipart
            <span class="apidocSignatureSpan">(boy, cfg)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">busboy.multipart.</span>detect</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.busboy.multipart.prototype">module busboy.multipart.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.multipart.prototype.end">
            function <span class="apidocSignatureSpan">busboy.multipart.prototype.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.multipart.prototype.write">
            function <span class="apidocSignatureSpan">busboy.multipart.prototype.</span>write
            <span class="apidocSignatureSpan">(chunk, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.busboy.urlencoded">module busboy.urlencoded</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.urlencoded.urlencoded">
            function <span class="apidocSignatureSpan">busboy.</span>urlencoded
            <span class="apidocSignatureSpan">(boy, cfg)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">busboy.urlencoded.</span>detect</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.busboy.urlencoded.prototype">module busboy.urlencoded.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.urlencoded.prototype.end">
            function <span class="apidocSignatureSpan">busboy.urlencoded.prototype.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.urlencoded.prototype.write">
            function <span class="apidocSignatureSpan">busboy.urlencoded.prototype.</span>write
            <span class="apidocSignatureSpan">(data, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.busboy.utils">module busboy.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.utils.Decoder">
            function <span class="apidocSignatureSpan">busboy.utils.</span>Decoder
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.utils.basename">
            function <span class="apidocSignatureSpan">busboy.utils.</span>basename
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.utils.decodeText">
            function <span class="apidocSignatureSpan">busboy.utils.</span>decodeText
            <span class="apidocSignatureSpan">(text, textEncoding, destEncoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.utils.parseParams">
            function <span class="apidocSignatureSpan">busboy.utils.</span>parseParams
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.busboy" id="apidoc.module.busboy">module busboy</a></h1>


    <h2>
        <a href="#apidoc.element.busboy.busboy" id="apidoc.element.busboy.busboy">
        function <span class="apidocSignatureSpan"></span>busboy
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Busboy(opts) {
  if (!(this instanceof Busboy))
    return new Busboy(opts);
  if (opts.highWaterMark !== undefined)
    WritableStream.call(this, { highWaterMark: opts.highWaterMark });
  else
    WritableStream.call(this);

  this._done = false;
  this._parser = undefined;
  this._finished = false;

  this.opts = opts;
  if (opts.headers &#x26;&#x26; typeof opts.headers[&#x27;content-type&#x27;] === &#x27;string&#x27;)
    this.parseHeaders(opts.headers);
  else
    throw new Error(&#x27;Missing Content-Type&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.busboy.multipart" id="apidoc.element.busboy.multipart">
        function <span class="apidocSignatureSpan">busboy.</span>multipart
        <span class="apidocSignatureSpan">(boy, cfg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Multipart(boy, cfg) {
  if (!(this instanceof Multipart))
    return new Multipart(boy, cfg);
  var i,
      len,
      self = this,
      boundary,
      limits = cfg.limits,
      parsedConType = cfg.parsedConType || [],
      defCharset = cfg.defCharset || &#x27;utf8&#x27;,
      preservePath = cfg.preservePath,
      fileopts = (typeof cfg.fileHwm === &#x27;number&#x27;
                  ? { highWaterMark: cfg.fileHwm }
                  : {});

  for (i = 0, len = parsedConType.length; i &#x3c; len; ++i) {
    if (Array.isArray(parsedConType[i])
        &#x26;&#x26; RE_BOUNDARY.test(parsedConType[i][0])) {
      boundary = parsedConType[i][1];
      break;
    }
  }

  function checkFinished() {
    if (nends === 0 &#x26;&#x26; finished &#x26;&#x26; !boy._done) {
      finished = false;
      process.nextTick(function() {
        boy._done = true;
        boy.emit(&#x27;finish&#x27;);
      });
    }
  }

  if (typeof boundary !== &#x27;string&#x27;)
    throw new Error(&#x27;Multipart: Boundary not found&#x27;);

  var fieldSizeLimit = (limits &#x26;&#x26; typeof limits.fieldSize === &#x27;number&#x27;
                        ? limits.fieldSize
                        : 1 * 1024 * 1024),
      fileSizeLimit = (limits &#x26;&#x26; typeof limits.fileSize === &#x27;number&#x27;
                       ? limits.fileSize
                       : Infinity),
      filesLimit = (limits &#x26;&#x26; typeof limits.files === &#x27;number&#x27;
                    ? limits.files
                    : Infinity),
      fieldsLimit = (limits &#x26;&#x26; typeof limits.fields === &#x27;number&#x27;
                     ? limits.fields
                     : Infinity),
      partsLimit = (limits &#x26;&#x26; typeof limits.parts === &#x27;number&#x27;
                    ? limits.parts
                    : Infinity);

  var nfiles = 0,
      nfields = 0,
      nends = 0,
      curFile,
      curField,
      finished = false;

  this._needDrain = false;
  this._pause = false;
  this._cb = undefined;
  this._nparts = 0;
  this._boy = boy;

  var parserCfg = {
    boundary: boundary,
    maxHeaderPairs: (limits &#x26;&#x26; limits.headerPairs)
  };
  if (fileopts.highWaterMark)
    parserCfg.partHwm = fileopts.highWaterMark;
  if (cfg.highWaterMark)
    parserCfg.highWaterMark = cfg.highWaterMark;

  this.parser = new Dicer(parserCfg);
  this.parser.on(&#x27;drain&#x27;, function() {
    self._needDrain = false;
    if (self._cb &#x26;&#x26; !self._pause) {
      var cb = self._cb;
      self._cb = undefined;
      cb();
    }
  }).on(&#x27;part&#x27;, function onPart(part) {
    if (++self._nparts &#x3e; partsLimit) {
      self.parser.removeListener(&#x27;part&#x27;, onPart);
      self.parser.on(&#x27;part&#x27;, skipPart);
      boy.hitPartsLimit = true;
      boy.emit(&#x27;partsLimit&#x27;);
      return skipPart(part);
    }

    // hack because streams2 _always_ doesn&#x27;t emit &#x27;end&#x27; until nextTick, so let
    // us emit &#x27;end&#x27; early since we know the part has ended if we are already
    // seeing the next part
    if (curField) {
      var field = curField;
      field.emit(&#x27;end&#x27;);
      field.removeAllListeners(&#x27;end&#x27;);
    }

    part.on(&#x27;header&#x27;, function(header) {
      var contype,
          fieldname,
          parsed,
          charset,
          encoding,
          filename,
          nsize = 0;

      if (header[&#x27;content-type&#x27;]) {
        parsed = parseParams(header[&#x27;content-type&#x27;][0]);
        if (parsed[0]) {
          contype = parsed[0].toLowerCase();
          for (i = 0, len = parsed.length; i &#x3c; len; ++i) {
            if (RE_CHARSET.test(parsed[i][0])) {
              charset = parsed[i][1].toLowerCase();
              break;
            }
          }
        }
      }

      if (contype === undefined)
        contype = &#x27;text/plain&#x27;;
      if (charset === undefined)
        charset = defCharset;

      if (header[&#x27;content-disposition&#x27;]) {
        parsed = parseParams(header[&#x27;content-disposition&#x27;][0]);
        if (!RE_FIELD.test(parsed[0]))
          return skipPart(part);
        for (i = 0, len = parsed.length; i &#x3c; len; ++i) {
          if (RE_NAME.test(parsed[i][0])) {
            fieldname = decodeText(parsed[i][1], &#x27;binary&#x27;, &#x27;utf8&#x27;);
          } else if (RE_FILENAME.test(parsed[i][0])) {
            filename = decodeText(parsed[i][1], &#x27;binary&#x27;, &#x27;utf8&#x27;); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.busboy.super_" id="apidoc.element.busboy.super_">
        function <span class="apidocSignatureSpan">busboy.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Writable(options) {
  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!(realHasInstance.call(Writable, this)) &#x26;&#x26;
      !(this instanceof Stream.Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === &#x27;function&#x27;)
      this._write = options.write;

    if (typeof options.writev === &#x27;function&#x27;)
      this._writev = options.writev;
  }

  Stream.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.busboy.urlencoded" id="apidoc.element.busboy.urlencoded">
        function <span class="apidocSignatureSpan">busboy.</span>urlencoded
        <span class="apidocSignatureSpan">(boy, cfg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function UrlEncoded(boy, cfg) {
  if (!(this instanceof UrlEncoded))
    return new UrlEncoded(boy, cfg);
  var limits = cfg.limits,
      headers = cfg.headers,
      parsedConType = cfg.parsedConType;
  this.boy = boy;

  this.fieldSizeLimit = (limits &#x26;&#x26; typeof limits.fieldSize === &#x27;number&#x27;
                         ? limits.fieldSize
                         : 1 * 1024 * 1024);
  this.fieldNameSizeLimit = (limits &#x26;&#x26; typeof limits.fieldNameSize === &#x27;number&#x27;
                             ? limits.fieldNameSize
                             : 100);
  this.fieldsLimit = (limits &#x26;&#x26; typeof limits.fields === &#x27;number&#x27;
                      ? limits.fields
                      : Infinity);

  var charset;
  for (var i = 0, len = parsedConType.length; i &#x3c; len; ++i) {
    if (Array.isArray(parsedConType[i])
        &#x26;&#x26; RE_CHARSET.test(parsedConType[i][0])) {
      charset = parsedConType[i][1].toLowerCase();
      break;
    }
  }

  if (charset === undefined)
    charset = cfg.defCharset || &#x27;utf8&#x27;;

  this.decoder = new Decoder();
  this.charset = charset;
  this._fields = 0;
  this._state = &#x27;key&#x27;;
  this._checkingBytes = true;
  this._bytesKey = 0;
  this._bytesVal = 0;
  this._key = &#x27;&#x27;;
  this._val = &#x27;&#x27;;
  this._keyTrunc = false;
  this._valTrunc = false;
  this._hitlimit = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.busboy.encoding" id="apidoc.module.busboy.encoding">module busboy.encoding</a></h1>


    <h2>
        <a href="#apidoc.element.busboy.encoding.TextDecoder" id="apidoc.element.busboy.encoding.TextDecoder">
        function <span class="apidocSignatureSpan">busboy.encoding.</span>TextDecoder
        <span class="apidocSignatureSpan">(opt_encoding, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TextDecoder(opt_encoding, options) {
  if (!(this instanceof TextDecoder)) {
    return new TextDecoder(opt_encoding, options);
  }
  opt_encoding = opt_encoding ? String(opt_encoding) : DEFAULT_ENCODING;
  options = Object(options);
<span class="apidocCodeCommentSpan">  /** @private */
</span>  this._encoding = getEncoding(opt_encoding);
  if (this._encoding === null || this._encoding.name === &#x27;replacement&#x27;)
    throw new TypeError(&#x27;Unknown encoding: &#x27; + opt_encoding);

  /** @private @type {boolean} */
  this._streaming = false;
  /** @private @type {boolean} */
  this._BOMseen = false;
  /** @private */
  this._decoder = null;
  /** @private @type {{fatal: boolean}=} */
  this._options = { fatal: Boolean(options.fatal) };

  if (Object.defineProperty) {
    Object.defineProperty(
        this, &#x27;encoding&#x27;,
        { get: function() { return this._encoding.name; } });
  } else {
    this.encoding = this._encoding.name;
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exports.parseParams = parseParams;


function decodeText(text, textEncoding, destEncoding) {
  var ret;
  if (text &#x26;&#x26; jsencoding.encodingExists(destEncoding)) {
    try {
      ret = jsencoding.<span class="apidocCodeKeywordSpan">TextDecoder</span>(destEncoding)
                      .decode(new Buffer(text, textEncoding));
    } catch(e) {}
  }
  return (typeof ret === &#x27;string&#x27; ? ret : text);
}
exports.decodeText = decodeText;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.busboy.encoding.TextEncoder" id="apidoc.element.busboy.encoding.TextEncoder">
        function <span class="apidocSignatureSpan">busboy.encoding.</span>TextEncoder
        <span class="apidocSignatureSpan">(opt_encoding, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TextEncoder(opt_encoding, options) {
  if (!(this instanceof TextEncoder)) {
    return new TextEncoder(opt_encoding, options);
  }
  opt_encoding = opt_encoding ? String(opt_encoding) : DEFAULT_ENCODING;
  options = Object(options);
<span class="apidocCodeCommentSpan">  /** @private */
</span>  this._encoding = getEncoding(opt_encoding);
  if (this._encoding === null || (this._encoding.name !== &#x27;utf-8&#x27; &#x26;&#x26;
                                  this._encoding.name !== &#x27;utf-16le&#x27; &#x26;&#x26;
                                  this._encoding.name !== &#x27;utf-16be&#x27;))
    throw new TypeError(&#x27;Unknown encoding: &#x27; + opt_encoding);
  /** @private @type {boolean} */
  this._streaming = false;
  /** @private */
  this._encoder = null;
  /** @private @type {{fatal: boolean}=} */
  this._options = { fatal: Boolean(options.fatal) };

  if (Object.defineProperty) {
    Object.defineProperty(
        this, &#x27;encoding&#x27;,
        { get: function() { return this._encoding.name; } });
  } else {
    this.encoding = this._encoding.name;
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.busboy.encoding.encodingExists" id="apidoc.element.busboy.encoding.encodingExists">
        function <span class="apidocSignatureSpan">busboy.encoding.</span>encodingExists
        <span class="apidocSignatureSpan">(label)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getEncoding(label) {
  label = String(label).trim().toLowerCase();
  if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {
    return label_to_encoding[label];
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return res;
};
exports.parseParams = parseParams;


function decodeText(text, textEncoding, destEncoding) {
  var ret;
  if (text &#x26;&#x26; jsencoding.<span class="apidocCodeKeywordSpan">encodingExists</span>(destEncoding)) {
    try {
      ret = jsencoding.TextDecoder(destEncoding)
                      .decode(new Buffer(text, textEncoding));
    } catch(e) {}
  }
  return (typeof ret === &#x27;string&#x27; ? ret : text);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.busboy.multipart" id="apidoc.module.busboy.multipart">module busboy.multipart</a></h1>


    <h2>
        <a href="#apidoc.element.busboy.multipart.multipart" id="apidoc.element.busboy.multipart.multipart">
        function <span class="apidocSignatureSpan">busboy.</span>multipart
        <span class="apidocSignatureSpan">(boy, cfg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Multipart(boy, cfg) {
  if (!(this instanceof Multipart))
    return new Multipart(boy, cfg);
  var i,
      len,
      self = this,
      boundary,
      limits = cfg.limits,
      parsedConType = cfg.parsedConType || [],
      defCharset = cfg.defCharset || &#x27;utf8&#x27;,
      preservePath = cfg.preservePath,
      fileopts = (typeof cfg.fileHwm === &#x27;number&#x27;
                  ? { highWaterMark: cfg.fileHwm }
                  : {});

  for (i = 0, len = parsedConType.length; i &#x3c; len; ++i) {
    if (Array.isArray(parsedConType[i])
        &#x26;&#x26; RE_BOUNDARY.test(parsedConType[i][0])) {
      boundary = parsedConType[i][1];
      break;
    }
  }

  function checkFinished() {
    if (nends === 0 &#x26;&#x26; finished &#x26;&#x26; !boy._done) {
      finished = false;
      process.nextTick(function() {
        boy._done = true;
        boy.emit(&#x27;finish&#x27;);
      });
    }
  }

  if (typeof boundary !== &#x27;string&#x27;)
    throw new Error(&#x27;Multipart: Boundary not found&#x27;);

  var fieldSizeLimit = (limits &#x26;&#x26; typeof limits.fieldSize === &#x27;number&#x27;
                        ? limits.fieldSize
                        : 1 * 1024 * 1024),
      fileSizeLimit = (limits &#x26;&#x26; typeof limits.fileSize === &#x27;number&#x27;
                       ? limits.fileSize
                       : Infinity),
      filesLimit = (limits &#x26;&#x26; typeof limits.files === &#x27;number&#x27;
                    ? limits.files
                    : Infinity),
      fieldsLimit = (limits &#x26;&#x26; typeof limits.fields === &#x27;number&#x27;
                     ? limits.fields
                     : Infinity),
      partsLimit = (limits &#x26;&#x26; typeof limits.parts === &#x27;number&#x27;
                    ? limits.parts
                    : Infinity);

  var nfiles = 0,
      nfields = 0,
      nends = 0,
      curFile,
      curField,
      finished = false;

  this._needDrain = false;
  this._pause = false;
  this._cb = undefined;
  this._nparts = 0;
  this._boy = boy;

  var parserCfg = {
    boundary: boundary,
    maxHeaderPairs: (limits &#x26;&#x26; limits.headerPairs)
  };
  if (fileopts.highWaterMark)
    parserCfg.partHwm = fileopts.highWaterMark;
  if (cfg.highWaterMark)
    parserCfg.highWaterMark = cfg.highWaterMark;

  this.parser = new Dicer(parserCfg);
  this.parser.on(&#x27;drain&#x27;, function() {
    self._needDrain = false;
    if (self._cb &#x26;&#x26; !self._pause) {
      var cb = self._cb;
      self._cb = undefined;
      cb();
    }
  }).on(&#x27;part&#x27;, function onPart(part) {
    if (++self._nparts &#x3e; partsLimit) {
      self.parser.removeListener(&#x27;part&#x27;, onPart);
      self.parser.on(&#x27;part&#x27;, skipPart);
      boy.hitPartsLimit = true;
      boy.emit(&#x27;partsLimit&#x27;);
      return skipPart(part);
    }

    // hack because streams2 _always_ doesn&#x27;t emit &#x27;end&#x27; until nextTick, so let
    // us emit &#x27;end&#x27; early since we know the part has ended if we are already
    // seeing the next part
    if (curField) {
      var field = curField;
      field.emit(&#x27;end&#x27;);
      field.removeAllListeners(&#x27;end&#x27;);
    }

    part.on(&#x27;header&#x27;, function(header) {
      var contype,
          fieldname,
          parsed,
          charset,
          encoding,
          filename,
          nsize = 0;

      if (header[&#x27;content-type&#x27;]) {
        parsed = parseParams(header[&#x27;content-type&#x27;][0]);
        if (parsed[0]) {
          contype = parsed[0].toLowerCase();
          for (i = 0, len = parsed.length; i &#x3c; len; ++i) {
            if (RE_CHARSET.test(parsed[i][0])) {
              charset = parsed[i][1].toLowerCase();
              break;
            }
          }
        }
      }

      if (contype === undefined)
        contype = &#x27;text/plain&#x27;;
      if (charset === undefined)
        charset = defCharset;

      if (header[&#x27;content-disposition&#x27;]) {
        parsed = parseParams(header[&#x27;content-disposition&#x27;][0]);
        if (!RE_FIELD.test(parsed[0]))
          return skipPart(part);
        for (i = 0, len = parsed.length; i &#x3c; len; ++i) {
          if (RE_NAME.test(parsed[i][0])) {
            fieldname = decodeText(parsed[i][1], &#x27;binary&#x27;, &#x27;utf8&#x27;);
          } else if (RE_FILENAME.test(parsed[i][0])) {
            filename = decodeText(parsed[i][1], &#x27;binary&#x27;, &#x27;utf8&#x27;); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.busboy.multipart.prototype" id="apidoc.module.busboy.multipart.prototype">module busboy.multipart.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.busboy.multipart.prototype.end" id="apidoc.element.busboy.multipart.prototype.end">
        function <span class="apidocSignatureSpan">busboy.multipart.prototype.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function () {
  var self = this;
  if (this._nparts === 0 &#x26;&#x26; !self._boy._done) {
    process.nextTick(function() {
      self._boy._done = true;
      self._boy.emit(&#x27;finish&#x27;);
    });
  } else if (this.parser.writable)
    this.parser.end();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var self = this;
  if (this._nparts === 0 &#x26;&#x26; !self._boy._done) {
    process.nextTick(function() {
      self._boy._done = true;
      self._boy.emit(&#x27;finish&#x27;);
    });
  } else if (this.parser.writable)
    this.parser.<span class="apidocCodeKeywordSpan">end</span>();
};

function skipPart(part) {
  part.resume();
}

function FileStream(opts) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.busboy.multipart.prototype.write" id="apidoc.element.busboy.multipart.prototype.write">
        function <span class="apidocSignatureSpan">busboy.multipart.prototype.</span>write
        <span class="apidocSignatureSpan">(chunk, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (chunk, cb) {
  var r;
  if ((r = this.parser.write(chunk)) &#x26;&#x26; !this._pause)
    cb();
  else {
    this._needDrain = !r;
    this._cb = cb;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    finished = true;
    checkFinished();
  });
}

Multipart.prototype.write = function(chunk, cb) {
  var r;
  if ((r = this.parser.<span class="apidocCodeKeywordSpan">write</span>(chunk)) &#x26;&#x26; !this._pause)
    cb();
  else {
    this._needDrain = !r;
    this._cb = cb;
  }
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.busboy.urlencoded" id="apidoc.module.busboy.urlencoded">module busboy.urlencoded</a></h1>


    <h2>
        <a href="#apidoc.element.busboy.urlencoded.urlencoded" id="apidoc.element.busboy.urlencoded.urlencoded">
        function <span class="apidocSignatureSpan">busboy.</span>urlencoded
        <span class="apidocSignatureSpan">(boy, cfg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function UrlEncoded(boy, cfg) {
  if (!(this instanceof UrlEncoded))
    return new UrlEncoded(boy, cfg);
  var limits = cfg.limits,
      headers = cfg.headers,
      parsedConType = cfg.parsedConType;
  this.boy = boy;

  this.fieldSizeLimit = (limits &#x26;&#x26; typeof limits.fieldSize === &#x27;number&#x27;
                         ? limits.fieldSize
                         : 1 * 1024 * 1024);
  this.fieldNameSizeLimit = (limits &#x26;&#x26; typeof limits.fieldNameSize === &#x27;number&#x27;
                             ? limits.fieldNameSize
                             : 100);
  this.fieldsLimit = (limits &#x26;&#x26; typeof limits.fields === &#x27;number&#x27;
                      ? limits.fields
                      : Infinity);

  var charset;
  for (var i = 0, len = parsedConType.length; i &#x3c; len; ++i) {
    if (Array.isArray(parsedConType[i])
        &#x26;&#x26; RE_CHARSET.test(parsedConType[i][0])) {
      charset = parsedConType[i][1].toLowerCase();
      break;
    }
  }

  if (charset === undefined)
    charset = cfg.defCharset || &#x27;utf8&#x27;;

  this.decoder = new Decoder();
  this.charset = charset;
  this._fields = 0;
  this._state = &#x27;key&#x27;;
  this._checkingBytes = true;
  this._bytesKey = 0;
  this._bytesVal = 0;
  this._key = &#x27;&#x27;;
  this._val = &#x27;&#x27;;
  this._keyTrunc = false;
  this._valTrunc = false;
  this._hitlimit = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.busboy.urlencoded.prototype" id="apidoc.module.busboy.urlencoded.prototype">module busboy.urlencoded.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.busboy.urlencoded.prototype.end" id="apidoc.element.busboy.urlencoded.prototype.end">
        function <span class="apidocSignatureSpan">busboy.urlencoded.prototype.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function () {
  if (this.boy._done)
    return;

  if (this._state === &#x27;key&#x27; &#x26;&#x26; this._key.length &#x3e; 0) {
    this.boy.emit(&#x27;field&#x27;, decodeText(this._key, &#x27;binary&#x27;, this.charset),
                           &#x27;&#x27;,
                           this._keyTrunc,
                           false);
  } else if (this._state === &#x27;val&#x27;) {
    this.boy.emit(&#x27;field&#x27;, decodeText(this._key, &#x27;binary&#x27;, this.charset),
                           decodeText(this._val, &#x27;binary&#x27;, this.charset),
                           this._keyTrunc,
                           this._valTrunc);
  }
  this.boy._done = true;
  this.boy.emit(&#x27;finish&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var self = this;
  if (this._nparts === 0 &#x26;&#x26; !self._boy._done) {
    process.nextTick(function() {
      self._boy._done = true;
      self._boy.emit(&#x27;finish&#x27;);
    });
  } else if (this.parser.writable)
    this.parser.<span class="apidocCodeKeywordSpan">end</span>();
};

function skipPart(part) {
  part.resume();
}

function FileStream(opts) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.busboy.urlencoded.prototype.write" id="apidoc.element.busboy.urlencoded.prototype.write">
        function <span class="apidocSignatureSpan">busboy.urlencoded.prototype.</span>write
        <span class="apidocSignatureSpan">(data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (data, cb) {
  if (this._fields === this.fieldsLimit) {
    if (!this.boy.hitFieldsLimit) {
      this.boy.hitFieldsLimit = true;
      this.boy.emit(&#x27;fieldsLimit&#x27;);
    }
    return cb();
  }

  var idxeq, idxamp, i, p = 0, len = data.length;

  while (p &#x3c; len) {
    if (this._state === &#x27;key&#x27;) {
      idxeq = idxamp = undefined;
      for (i = p; i &#x3c; len; ++i) {
        if (!this._checkingBytes)
          ++p;
        if (data[i] === 0x3D/*=*/) {
          idxeq = i;
          break;
        } else if (data[i] === 0x26/*&#x26;*/) {
          idxamp = i;
          break;
        }
        if (this._checkingBytes &#x26;&#x26; this._bytesKey === this.fieldNameSizeLimit) {
          this._hitLimit = true;
          break;
        } else if (this._checkingBytes)
          ++this._bytesKey;
      }

      if (idxeq !== undefined) {
        // key with assignment
        if (idxeq &#x3e; p)
          this._key += this.decoder.write(data.toString(&#x27;binary&#x27;, p, idxeq));
        this._state = &#x27;val&#x27;;

        this._hitLimit = false;
        this._checkingBytes = true;
        this._val = &#x27;&#x27;;
        this._bytesVal = 0;
        this._valTrunc = false;
        this.decoder.reset();

        p = idxeq + 1;
      } else if (idxamp !== undefined) {
        // key with no assignment
        ++this._fields;
        var key, keyTrunc = this._keyTrunc;
        if (idxamp &#x3e; p)
          key = (this._key += this.decoder.write(data.toString(&#x27;binary&#x27;, p, idxamp)));
        else
          key = this._key;

        this._hitLimit = false;
        this._checkingBytes = true;
        this._key = &#x27;&#x27;;
        this._bytesKey = 0;
        this._keyTrunc = false;
        this.decoder.reset();

        if (key.length) {
          this.boy.emit(&#x27;field&#x27;, decodeText(key, &#x27;binary&#x27;, this.charset),
                                 &#x27;&#x27;,
                                 keyTrunc,
                                 false);
        }

        p = idxamp + 1;
        if (this._fields === this.fieldsLimit)
          return cb();
      } else if (this._hitLimit) {
        // we may not have hit the actual limit if there are encoded bytes...
        if (i &#x3e; p)
          this._key += this.decoder.write(data.toString(&#x27;binary&#x27;, p, i));
        p = i;
        if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
          // yep, we actually did hit the limit
          this._checkingBytes = false;
          this._keyTrunc = true;
        }
      } else {
        if (p &#x3c; len)
          this._key += this.decoder.write(data.toString(&#x27;binary&#x27;, p));
        p = len;
      }
    } else {
      idxamp = undefined;
      for (i = p; i &#x3c; len; ++i) {
        if (!this._checkingBytes)
          ++p;
        if (data[i] === 0x26/*&#x26;*/) {
          idxamp = i;
          break;
        }
        if (this._checkingBytes &#x26;&#x26; this._bytesVal === this.fieldSizeLimit) {
          this._hitLimit = true;
          break;
        }
        else if (this._checkingBytes)
          ++this._bytesVal;
      }

      if (idxamp !== undefined) {
        ++this._fields;
        if (idxamp &#x3e; p)
          this._val += this.decoder.write(data.toString(&#x27;binary&#x27;, p, idxamp));
        this.boy.emit(&#x27;field&#x27;, decodeText(this._key, &#x27;binary&#x27;, this.charset),
                               decodeText(this._val, &#x27;binary&#x27;, this.charset),
                               this._keyTrunc,
                               this._valTrunc);
        this._state = &#x27;key&#x27;;

        this._hitLimit = false;
        this._checkingBytes = true;
        this._key = &#x27;&#x27;;
        this._bytesKey = 0;
        this._keyTrunc = false;
        this.decoder.reset();

        p = idxamp + 1;
        if (this._fields === this.fieldsLimit)
          return cb();
      } else if (this._hitLimit) {
        // we may not have hit the actual limit if there are encoded bytes...
        if (i &#x3e; p)
          this._val += this.decoder.write(data.toString(&#x27;binary&#x27;, p, i));
        p = i;
        if ((this._val === &#x27;&#x27; &#x26;&#x26; this.fieldSizeLimit === 0)
            || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {
          // yep, we actually d ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    finished = true;
    checkFinished();
  });
}

Multipart.prototype.write = function(chunk, cb) {
  var r;
  if ((r = this.parser.<span class="apidocCodeKeywordSpan">write</span>(chunk)) &#x26;&#x26; !this._pause)
    cb();
  else {
    this._needDrain = !r;
    this._cb = cb;
  }
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.busboy.utils" id="apidoc.module.busboy.utils">module busboy.utils</a></h1>


    <h2>
        <a href="#apidoc.element.busboy.utils.Decoder" id="apidoc.element.busboy.utils.Decoder">
        function <span class="apidocSignatureSpan">busboy.utils.</span>Decoder
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Decoder() {
  this.buffer = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.busboy.utils.basename" id="apidoc.element.busboy.utils.basename">
        function <span class="apidocSignatureSpan">busboy.utils.</span>basename
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function basename(path) {
  var f = splitPathPosix(path)[2];
  if (f === path)
    f = splitPathWindows(path)[2];
  return f;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.busboy.utils.decodeText" id="apidoc.element.busboy.utils.decodeText">
        function <span class="apidocSignatureSpan">busboy.utils.</span>decodeText
        <span class="apidocSignatureSpan">(text, textEncoding, destEncoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decodeText(text, textEncoding, destEncoding) {
  var ret;
  if (text &#x26;&#x26; jsencoding.encodingExists(destEncoding)) {
    try {
      ret = jsencoding.TextDecoder(destEncoding)
                      .decode(new Buffer(text, textEncoding));
    } catch(e) {}
  }
  return (typeof ret === &#x27;string&#x27; ? ret : text);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.busboy.utils.parseParams" id="apidoc.element.busboy.utils.parseParams">
        function <span class="apidocSignatureSpan">busboy.utils.</span>parseParams
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseParams(str) {
  var res = [],
      state = &#x27;key&#x27;,
      charset = &#x27;&#x27;,
      inquote = false,
      escaping = false,
      p = 0,
      tmp = &#x27;&#x27;;

  for (var i = 0, len = str.length; i &#x3c; len; ++i) {
    if (str[i] === &#x27;\\&#x27; &#x26;&#x26; inquote) {
      if (escaping)
        escaping = false;
      else {
        escaping = true;
        continue;
      }
    } else if (str[i] === &#x27;&#x22;&#x27;) {
      if (!escaping) {
        if (inquote) {
          inquote = false;
          state = &#x27;key&#x27;;
        } else
          inquote = true;
        continue;
      } else
        escaping = false;
    } else {
      if (escaping &#x26;&#x26; inquote)
        tmp += &#x27;\\&#x27;;
      escaping = false;
      if ((state === &#x27;charset&#x27; || state === &#x27;lang&#x27;) &#x26;&#x26; str[i] === &#x22;&#x27;&#x22;) {
        if (state === &#x27;charset&#x27;) {
          state = &#x27;lang&#x27;;
          charset = tmp.substring(1);
        } else
          state = &#x27;value&#x27;;
        tmp = &#x27;&#x27;;
        continue;
      } else if (state === &#x27;key&#x27;
                 &#x26;&#x26; (str[i] === &#x27;*&#x27; || str[i] === &#x27;=&#x27;)
                 &#x26;&#x26; res.length) {
        if (str[i] === &#x27;*&#x27;)
          state = &#x27;charset&#x27;;
        else
          state = &#x27;value&#x27;;
        res[p] = [tmp, undefined];
        tmp = &#x27;&#x27;;
        continue;
      } else if (!inquote &#x26;&#x26; str[i] === &#x27;;&#x27;) {
        state = &#x27;key&#x27;;
        if (charset) {
          if (tmp.length) {
            tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer),
                             &#x27;binary&#x27;,
                             charset);
          }
          charset = &#x27;&#x27;;
        }
        if (res[p] === undefined)
          res[p] = tmp;
        else
          res[p][1] = tmp;
        tmp = &#x27;&#x27;;
        ++p;
        continue;
      } else if (!inquote &#x26;&#x26; (str[i] === &#x27; &#x27; || str[i] === &#x27;\t&#x27;))
        continue;
    }
    tmp += str[i];
  }
  if (charset &#x26;&#x26; tmp.length) {
    tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer),
                     &#x27;binary&#x27;,
                     charset);
  }

  if (res[p] === undefined) {
    if (tmp)
      res[p] = tmp;
  } else
    res[p][1] = tmp;

  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
