<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/mscdex/busboy#readme">busboy (v0.2.14)</a>
</h1>
<h4>A streaming parser for HTML form data for node.js</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.busboy">module busboy</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.busboy">
            function <span class="apidocSignatureSpan"></span>busboy
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.multipart">
            function <span class="apidocSignatureSpan">busboy.</span>multipart
            <span class="apidocSignatureSpan">(boy, cfg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.super_">
            function <span class="apidocSignatureSpan">busboy.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.urlencoded">
            function <span class="apidocSignatureSpan">busboy.</span>urlencoded
            <span class="apidocSignatureSpan">(boy, cfg)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">busboy.</span>encoding</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">busboy.</span>multipart.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">busboy.</span>urlencoded.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">busboy.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.busboy.encoding">module busboy.encoding</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.encoding.TextDecoder">
            function <span class="apidocSignatureSpan">busboy.encoding.</span>TextDecoder
            <span class="apidocSignatureSpan">(opt_encoding, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.encoding.TextEncoder">
            function <span class="apidocSignatureSpan">busboy.encoding.</span>TextEncoder
            <span class="apidocSignatureSpan">(opt_encoding, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.encoding.encodingExists">
            function <span class="apidocSignatureSpan">busboy.encoding.</span>encodingExists
            <span class="apidocSignatureSpan">(label)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.busboy.multipart">module busboy.multipart</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.multipart.multipart">
            function <span class="apidocSignatureSpan">busboy.</span>multipart
            <span class="apidocSignatureSpan">(boy, cfg)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">busboy.multipart.</span>detect</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.busboy.multipart.prototype">module busboy.multipart.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.multipart.prototype.end">
            function <span class="apidocSignatureSpan">busboy.multipart.prototype.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.multipart.prototype.write">
            function <span class="apidocSignatureSpan">busboy.multipart.prototype.</span>write
            <span class="apidocSignatureSpan">(chunk, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.busboy.urlencoded">module busboy.urlencoded</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.urlencoded.urlencoded">
            function <span class="apidocSignatureSpan">busboy.</span>urlencoded
            <span class="apidocSignatureSpan">(boy, cfg)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">busboy.urlencoded.</span>detect</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.busboy.urlencoded.prototype">module busboy.urlencoded.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.urlencoded.prototype.end">
            function <span class="apidocSignatureSpan">busboy.urlencoded.prototype.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.urlencoded.prototype.write">
            function <span class="apidocSignatureSpan">busboy.urlencoded.prototype.</span>write
            <span class="apidocSignatureSpan">(data, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.busboy.utils">module busboy.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.utils.Decoder">
            function <span class="apidocSignatureSpan">busboy.utils.</span>Decoder
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.utils.basename">
            function <span class="apidocSignatureSpan">busboy.utils.</span>basename
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.utils.decodeText">
            function <span class="apidocSignatureSpan">busboy.utils.</span>decodeText
            <span class="apidocSignatureSpan">(text, textEncoding, destEncoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.busboy.utils.parseParams">
            function <span class="apidocSignatureSpan">busboy.utils.</span>parseParams
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.busboy" id="apidoc.module.busboy">module busboy</a></h1>


    <h2>
        <a href="#apidoc.element.busboy.busboy" id="apidoc.element.busboy.busboy">
        function <span class="apidocSignatureSpan"></span>busboy
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Busboy(opts) {
  if (!(this instanceof Busboy))
    return new Busboy(opts);
  if (opts.highWaterMark !== undefined)
    WritableStream.call(this, { highWaterMark: opts.highWaterMark });
  else
    WritableStream.call(this);

  this._done = false;
  this._parser = undefined;
  this._finished = false;

  this.opts = opts;
  if (opts.headers &amp;&amp; typeof opts.headers['content-type'] === 'string')
    this.parseHeaders(opts.headers);
  else
    throw new Error('Missing Content-Type');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.busboy.multipart" id="apidoc.element.busboy.multipart">
        function <span class="apidocSignatureSpan">busboy.</span>multipart
        <span class="apidocSignatureSpan">(boy, cfg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Multipart(boy, cfg) {
  if (!(this instanceof Multipart))
    return new Multipart(boy, cfg);
  var i,
      len,
      self = this,
      boundary,
      limits = cfg.limits,
      parsedConType = cfg.parsedConType || [],
      defCharset = cfg.defCharset || 'utf8',
      preservePath = cfg.preservePath,
      fileopts = (typeof cfg.fileHwm === 'number'
                  ? { highWaterMark: cfg.fileHwm }
                  : {});

  for (i = 0, len = parsedConType.length; i &lt; len; ++i) {
    if (Array.isArray(parsedConType[i])
        &amp;&amp; RE_BOUNDARY.test(parsedConType[i][0])) {
      boundary = parsedConType[i][1];
      break;
    }
  }

  function checkFinished() {
    if (nends === 0 &amp;&amp; finished &amp;&amp; !boy._done) {
      finished = false;
      process.nextTick(function() {
        boy._done = true;
        boy.emit('finish');
      });
    }
  }

  if (typeof boundary !== 'string')
    throw new Error('Multipart: Boundary not found');

  var fieldSizeLimit = (limits &amp;&amp; typeof limits.fieldSize === 'number'
                        ? limits.fieldSize
                        : 1 * 1024 * 1024),
      fileSizeLimit = (limits &amp;&amp; typeof limits.fileSize === 'number'
                       ? limits.fileSize
                       : Infinity),
      filesLimit = (limits &amp;&amp; typeof limits.files === 'number'
                    ? limits.files
                    : Infinity),
      fieldsLimit = (limits &amp;&amp; typeof limits.fields === 'number'
                     ? limits.fields
                     : Infinity),
      partsLimit = (limits &amp;&amp; typeof limits.parts === 'number'
                    ? limits.parts
                    : Infinity);

  var nfiles = 0,
      nfields = 0,
      nends = 0,
      curFile,
      curField,
      finished = false;

  this._needDrain = false;
  this._pause = false;
  this._cb = undefined;
  this._nparts = 0;
  this._boy = boy;

  var parserCfg = {
    boundary: boundary,
    maxHeaderPairs: (limits &amp;&amp; limits.headerPairs)
  };
  if (fileopts.highWaterMark)
    parserCfg.partHwm = fileopts.highWaterMark;
  if (cfg.highWaterMark)
    parserCfg.highWaterMark = cfg.highWaterMark;

  this.parser = new Dicer(parserCfg);
  this.parser.on('drain', function() {
    self._needDrain = false;
    if (self._cb &amp;&amp; !self._pause) {
      var cb = self._cb;
      self._cb = undefined;
      cb();
    }
  }).on('part', function onPart(part) {
    if (++self._nparts &gt; partsLimit) {
      self.parser.removeListener('part', onPart);
      self.parser.on('part', skipPart);
      boy.hitPartsLimit = true;
      boy.emit('partsLimit');
      return skipPart(part);
    }

    // hack because streams2 _always_ doesn't emit 'end' until nextTick, so let
    // us emit 'end' early since we know the part has ended if we are already
    // seeing the next part
    if (curField) {
      var field = curField;
      field.emit('end');
      field.removeAllListeners('end');
    }

    part.on('header', function(header) {
      var contype,
          fieldname,
          parsed,
          charset,
          encoding,
          filename,
          nsize = 0;

      if (header['content-type']) {
        parsed = parseParams(header['content-type'][0]);
        if (parsed[0]) {
          contype = parsed[0].toLowerCase();
          for (i = 0, len = parsed.length; i &lt; len; ++i) {
            if (RE_CHARSET.test(parsed[i][0])) {
              charset = parsed[i][1].toLowerCase();
              break;
            }
          }
        }
      }

      if (contype === undefined)
        contype = 'text/plain';
      if (charset === undefined)
        charset = defCharset;

      if (header['content-disposition']) {
        parsed = parseParams(header['content-disposition'][0]);
        if (!RE_FIELD.test(parsed[0]))
          return skipPart(part);
        for (i = 0, len = parsed.length; i &lt; len; ++i) {
          if (RE_NAME.test(parsed[i][0])) {
            fieldname = decodeText(parsed[i][1], 'binary', 'utf8');
          } else if (RE_FILENAME.test(parsed[i][0])) {
            filename = decodeText(parsed[i][1], 'binary', 'utf8'); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.busboy.super_" id="apidoc.element.busboy.super_">
        function <span class="apidocSignatureSpan">busboy.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Writable(options) {
  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!(realHasInstance.call(Writable, this)) &amp;&amp;
      !(this instanceof Stream.Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function')
      this._write = options.write;

    if (typeof options.writev === 'function')
      this._writev = options.writev;
  }

  Stream.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.busboy.urlencoded" id="apidoc.element.busboy.urlencoded">
        function <span class="apidocSignatureSpan">busboy.</span>urlencoded
        <span class="apidocSignatureSpan">(boy, cfg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function UrlEncoded(boy, cfg) {
  if (!(this instanceof UrlEncoded))
    return new UrlEncoded(boy, cfg);
  var limits = cfg.limits,
      headers = cfg.headers,
      parsedConType = cfg.parsedConType;
  this.boy = boy;

  this.fieldSizeLimit = (limits &amp;&amp; typeof limits.fieldSize === 'number'
                         ? limits.fieldSize
                         : 1 * 1024 * 1024);
  this.fieldNameSizeLimit = (limits &amp;&amp; typeof limits.fieldNameSize === 'number'
                             ? limits.fieldNameSize
                             : 100);
  this.fieldsLimit = (limits &amp;&amp; typeof limits.fields === 'number'
                      ? limits.fields
                      : Infinity);

  var charset;
  for (var i = 0, len = parsedConType.length; i &lt; len; ++i) {
    if (Array.isArray(parsedConType[i])
        &amp;&amp; RE_CHARSET.test(parsedConType[i][0])) {
      charset = parsedConType[i][1].toLowerCase();
      break;
    }
  }

  if (charset === undefined)
    charset = cfg.defCharset || 'utf8';

  this.decoder = new Decoder();
  this.charset = charset;
  this._fields = 0;
  this._state = 'key';
  this._checkingBytes = true;
  this._bytesKey = 0;
  this._bytesVal = 0;
  this._key = '';
  this._val = '';
  this._keyTrunc = false;
  this._valTrunc = false;
  this._hitlimit = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.busboy.encoding" id="apidoc.module.busboy.encoding">module busboy.encoding</a></h1>


    <h2>
        <a href="#apidoc.element.busboy.encoding.TextDecoder" id="apidoc.element.busboy.encoding.TextDecoder">
        function <span class="apidocSignatureSpan">busboy.encoding.</span>TextDecoder
        <span class="apidocSignatureSpan">(opt_encoding, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TextDecoder(opt_encoding, options) {
  if (!(this instanceof TextDecoder)) {
    return new TextDecoder(opt_encoding, options);
  }
  opt_encoding = opt_encoding ? String(opt_encoding) : DEFAULT_ENCODING;
  options = Object(options);
<span class="apidocCodeCommentSpan">  /** @private */
</span>  this._encoding = getEncoding(opt_encoding);
  if (this._encoding === null || this._encoding.name === 'replacement')
    throw new TypeError('Unknown encoding: ' + opt_encoding);

  /** @private @type {boolean} */
  this._streaming = false;
  /** @private @type {boolean} */
  this._BOMseen = false;
  /** @private */
  this._decoder = null;
  /** @private @type {{fatal: boolean}=} */
  this._options = { fatal: Boolean(options.fatal) };

  if (Object.defineProperty) {
    Object.defineProperty(
        this, 'encoding',
        { get: function() { return this._encoding.name; } });
  } else {
    this.encoding = this._encoding.name;
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exports.parseParams = parseParams;


function decodeText(text, textEncoding, destEncoding) {
  var ret;
  if (text &amp;&amp; jsencoding.encodingExists(destEncoding)) {
    try {
      ret = jsencoding.<span class="apidocCodeKeywordSpan">TextDecoder</span>(destEncoding)
                      .decode(new Buffer(text, textEncoding));
    } catch(e) {}
  }
  return (typeof ret === 'string' ? ret : text);
}
exports.decodeText = decodeText;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.busboy.encoding.TextEncoder" id="apidoc.element.busboy.encoding.TextEncoder">
        function <span class="apidocSignatureSpan">busboy.encoding.</span>TextEncoder
        <span class="apidocSignatureSpan">(opt_encoding, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TextEncoder(opt_encoding, options) {
  if (!(this instanceof TextEncoder)) {
    return new TextEncoder(opt_encoding, options);
  }
  opt_encoding = opt_encoding ? String(opt_encoding) : DEFAULT_ENCODING;
  options = Object(options);
<span class="apidocCodeCommentSpan">  /** @private */
</span>  this._encoding = getEncoding(opt_encoding);
  if (this._encoding === null || (this._encoding.name !== 'utf-8' &amp;&amp;
                                  this._encoding.name !== 'utf-16le' &amp;&amp;
                                  this._encoding.name !== 'utf-16be'))
    throw new TypeError('Unknown encoding: ' + opt_encoding);
  /** @private @type {boolean} */
  this._streaming = false;
  /** @private */
  this._encoder = null;
  /** @private @type {{fatal: boolean}=} */
  this._options = { fatal: Boolean(options.fatal) };

  if (Object.defineProperty) {
    Object.defineProperty(
        this, 'encoding',
        { get: function() { return this._encoding.name; } });
  } else {
    this.encoding = this._encoding.name;
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.busboy.encoding.encodingExists" id="apidoc.element.busboy.encoding.encodingExists">
        function <span class="apidocSignatureSpan">busboy.encoding.</span>encodingExists
        <span class="apidocSignatureSpan">(label)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getEncoding(label) {
  label = String(label).trim().toLowerCase();
  if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {
    return label_to_encoding[label];
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return res;
};
exports.parseParams = parseParams;


function decodeText(text, textEncoding, destEncoding) {
  var ret;
  if (text &amp;&amp; jsencoding.<span class="apidocCodeKeywordSpan">encodingExists</span>(destEncoding)) {
    try {
      ret = jsencoding.TextDecoder(destEncoding)
                      .decode(new Buffer(text, textEncoding));
    } catch(e) {}
  }
  return (typeof ret === 'string' ? ret : text);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.busboy.multipart" id="apidoc.module.busboy.multipart">module busboy.multipart</a></h1>


    <h2>
        <a href="#apidoc.element.busboy.multipart.multipart" id="apidoc.element.busboy.multipart.multipart">
        function <span class="apidocSignatureSpan">busboy.</span>multipart
        <span class="apidocSignatureSpan">(boy, cfg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Multipart(boy, cfg) {
  if (!(this instanceof Multipart))
    return new Multipart(boy, cfg);
  var i,
      len,
      self = this,
      boundary,
      limits = cfg.limits,
      parsedConType = cfg.parsedConType || [],
      defCharset = cfg.defCharset || 'utf8',
      preservePath = cfg.preservePath,
      fileopts = (typeof cfg.fileHwm === 'number'
                  ? { highWaterMark: cfg.fileHwm }
                  : {});

  for (i = 0, len = parsedConType.length; i &lt; len; ++i) {
    if (Array.isArray(parsedConType[i])
        &amp;&amp; RE_BOUNDARY.test(parsedConType[i][0])) {
      boundary = parsedConType[i][1];
      break;
    }
  }

  function checkFinished() {
    if (nends === 0 &amp;&amp; finished &amp;&amp; !boy._done) {
      finished = false;
      process.nextTick(function() {
        boy._done = true;
        boy.emit('finish');
      });
    }
  }

  if (typeof boundary !== 'string')
    throw new Error('Multipart: Boundary not found');

  var fieldSizeLimit = (limits &amp;&amp; typeof limits.fieldSize === 'number'
                        ? limits.fieldSize
                        : 1 * 1024 * 1024),
      fileSizeLimit = (limits &amp;&amp; typeof limits.fileSize === 'number'
                       ? limits.fileSize
                       : Infinity),
      filesLimit = (limits &amp;&amp; typeof limits.files === 'number'
                    ? limits.files
                    : Infinity),
      fieldsLimit = (limits &amp;&amp; typeof limits.fields === 'number'
                     ? limits.fields
                     : Infinity),
      partsLimit = (limits &amp;&amp; typeof limits.parts === 'number'
                    ? limits.parts
                    : Infinity);

  var nfiles = 0,
      nfields = 0,
      nends = 0,
      curFile,
      curField,
      finished = false;

  this._needDrain = false;
  this._pause = false;
  this._cb = undefined;
  this._nparts = 0;
  this._boy = boy;

  var parserCfg = {
    boundary: boundary,
    maxHeaderPairs: (limits &amp;&amp; limits.headerPairs)
  };
  if (fileopts.highWaterMark)
    parserCfg.partHwm = fileopts.highWaterMark;
  if (cfg.highWaterMark)
    parserCfg.highWaterMark = cfg.highWaterMark;

  this.parser = new Dicer(parserCfg);
  this.parser.on('drain', function() {
    self._needDrain = false;
    if (self._cb &amp;&amp; !self._pause) {
      var cb = self._cb;
      self._cb = undefined;
      cb();
    }
  }).on('part', function onPart(part) {
    if (++self._nparts &gt; partsLimit) {
      self.parser.removeListener('part', onPart);
      self.parser.on('part', skipPart);
      boy.hitPartsLimit = true;
      boy.emit('partsLimit');
      return skipPart(part);
    }

    // hack because streams2 _always_ doesn't emit 'end' until nextTick, so let
    // us emit 'end' early since we know the part has ended if we are already
    // seeing the next part
    if (curField) {
      var field = curField;
      field.emit('end');
      field.removeAllListeners('end');
    }

    part.on('header', function(header) {
      var contype,
          fieldname,
          parsed,
          charset,
          encoding,
          filename,
          nsize = 0;

      if (header['content-type']) {
        parsed = parseParams(header['content-type'][0]);
        if (parsed[0]) {
          contype = parsed[0].toLowerCase();
          for (i = 0, len = parsed.length; i &lt; len; ++i) {
            if (RE_CHARSET.test(parsed[i][0])) {
              charset = parsed[i][1].toLowerCase();
              break;
            }
          }
        }
      }

      if (contype === undefined)
        contype = 'text/plain';
      if (charset === undefined)
        charset = defCharset;

      if (header['content-disposition']) {
        parsed = parseParams(header['content-disposition'][0]);
        if (!RE_FIELD.test(parsed[0]))
          return skipPart(part);
        for (i = 0, len = parsed.length; i &lt; len; ++i) {
          if (RE_NAME.test(parsed[i][0])) {
            fieldname = decodeText(parsed[i][1], 'binary', 'utf8');
          } else if (RE_FILENAME.test(parsed[i][0])) {
            filename = decodeText(parsed[i][1], 'binary', 'utf8'); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.busboy.multipart.prototype" id="apidoc.module.busboy.multipart.prototype">module busboy.multipart.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.busboy.multipart.prototype.end" id="apidoc.element.busboy.multipart.prototype.end">
        function <span class="apidocSignatureSpan">busboy.multipart.prototype.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function () {
  var self = this;
  if (this._nparts === 0 &amp;&amp; !self._boy._done) {
    process.nextTick(function() {
      self._boy._done = true;
      self._boy.emit('finish');
    });
  } else if (this.parser.writable)
    this.parser.end();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var self = this;
  if (this._nparts === 0 &amp;&amp; !self._boy._done) {
    process.nextTick(function() {
      self._boy._done = true;
      self._boy.emit('finish');
    });
  } else if (this.parser.writable)
    this.parser.<span class="apidocCodeKeywordSpan">end</span>();
};

function skipPart(part) {
  part.resume();
}

function FileStream(opts) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.busboy.multipart.prototype.write" id="apidoc.element.busboy.multipart.prototype.write">
        function <span class="apidocSignatureSpan">busboy.multipart.prototype.</span>write
        <span class="apidocSignatureSpan">(chunk, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (chunk, cb) {
  var r;
  if ((r = this.parser.write(chunk)) &amp;&amp; !this._pause)
    cb();
  else {
    this._needDrain = !r;
    this._cb = cb;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    finished = true;
    checkFinished();
  });
}

Multipart.prototype.write = function(chunk, cb) {
  var r;
  if ((r = this.parser.<span class="apidocCodeKeywordSpan">write</span>(chunk)) &amp;&amp; !this._pause)
    cb();
  else {
    this._needDrain = !r;
    this._cb = cb;
  }
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.busboy.urlencoded" id="apidoc.module.busboy.urlencoded">module busboy.urlencoded</a></h1>


    <h2>
        <a href="#apidoc.element.busboy.urlencoded.urlencoded" id="apidoc.element.busboy.urlencoded.urlencoded">
        function <span class="apidocSignatureSpan">busboy.</span>urlencoded
        <span class="apidocSignatureSpan">(boy, cfg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function UrlEncoded(boy, cfg) {
  if (!(this instanceof UrlEncoded))
    return new UrlEncoded(boy, cfg);
  var limits = cfg.limits,
      headers = cfg.headers,
      parsedConType = cfg.parsedConType;
  this.boy = boy;

  this.fieldSizeLimit = (limits &amp;&amp; typeof limits.fieldSize === 'number'
                         ? limits.fieldSize
                         : 1 * 1024 * 1024);
  this.fieldNameSizeLimit = (limits &amp;&amp; typeof limits.fieldNameSize === 'number'
                             ? limits.fieldNameSize
                             : 100);
  this.fieldsLimit = (limits &amp;&amp; typeof limits.fields === 'number'
                      ? limits.fields
                      : Infinity);

  var charset;
  for (var i = 0, len = parsedConType.length; i &lt; len; ++i) {
    if (Array.isArray(parsedConType[i])
        &amp;&amp; RE_CHARSET.test(parsedConType[i][0])) {
      charset = parsedConType[i][1].toLowerCase();
      break;
    }
  }

  if (charset === undefined)
    charset = cfg.defCharset || 'utf8';

  this.decoder = new Decoder();
  this.charset = charset;
  this._fields = 0;
  this._state = 'key';
  this._checkingBytes = true;
  this._bytesKey = 0;
  this._bytesVal = 0;
  this._key = '';
  this._val = '';
  this._keyTrunc = false;
  this._valTrunc = false;
  this._hitlimit = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.busboy.urlencoded.prototype" id="apidoc.module.busboy.urlencoded.prototype">module busboy.urlencoded.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.busboy.urlencoded.prototype.end" id="apidoc.element.busboy.urlencoded.prototype.end">
        function <span class="apidocSignatureSpan">busboy.urlencoded.prototype.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function () {
  if (this.boy._done)
    return;

  if (this._state === 'key' &amp;&amp; this._key.length &gt; 0) {
    this.boy.emit('field', decodeText(this._key, 'binary', this.charset),
                           '',
                           this._keyTrunc,
                           false);
  } else if (this._state === 'val') {
    this.boy.emit('field', decodeText(this._key, 'binary', this.charset),
                           decodeText(this._val, 'binary', this.charset),
                           this._keyTrunc,
                           this._valTrunc);
  }
  this.boy._done = true;
  this.boy.emit('finish');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var self = this;
  if (this._nparts === 0 &amp;&amp; !self._boy._done) {
    process.nextTick(function() {
      self._boy._done = true;
      self._boy.emit('finish');
    });
  } else if (this.parser.writable)
    this.parser.<span class="apidocCodeKeywordSpan">end</span>();
};

function skipPart(part) {
  part.resume();
}

function FileStream(opts) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.busboy.urlencoded.prototype.write" id="apidoc.element.busboy.urlencoded.prototype.write">
        function <span class="apidocSignatureSpan">busboy.urlencoded.prototype.</span>write
        <span class="apidocSignatureSpan">(data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (data, cb) {
  if (this._fields === this.fieldsLimit) {
    if (!this.boy.hitFieldsLimit) {
      this.boy.hitFieldsLimit = true;
      this.boy.emit('fieldsLimit');
    }
    return cb();
  }

  var idxeq, idxamp, i, p = 0, len = data.length;

  while (p &lt; len) {
    if (this._state === 'key') {
      idxeq = idxamp = undefined;
      for (i = p; i &lt; len; ++i) {
        if (!this._checkingBytes)
          ++p;
        if (data[i] === 0x3D/*=*/) {
          idxeq = i;
          break;
        } else if (data[i] === 0x26/*&amp;*/) {
          idxamp = i;
          break;
        }
        if (this._checkingBytes &amp;&amp; this._bytesKey === this.fieldNameSizeLimit) {
          this._hitLimit = true;
          break;
        } else if (this._checkingBytes)
          ++this._bytesKey;
      }

      if (idxeq !== undefined) {
        // key with assignment
        if (idxeq &gt; p)
          this._key += this.decoder.write(data.toString('binary', p, idxeq));
        this._state = 'val';

        this._hitLimit = false;
        this._checkingBytes = true;
        this._val = '';
        this._bytesVal = 0;
        this._valTrunc = false;
        this.decoder.reset();

        p = idxeq + 1;
      } else if (idxamp !== undefined) {
        // key with no assignment
        ++this._fields;
        var key, keyTrunc = this._keyTrunc;
        if (idxamp &gt; p)
          key = (this._key += this.decoder.write(data.toString('binary', p, idxamp)));
        else
          key = this._key;

        this._hitLimit = false;
        this._checkingBytes = true;
        this._key = '';
        this._bytesKey = 0;
        this._keyTrunc = false;
        this.decoder.reset();

        if (key.length) {
          this.boy.emit('field', decodeText(key, 'binary', this.charset),
                                 '',
                                 keyTrunc,
                                 false);
        }

        p = idxamp + 1;
        if (this._fields === this.fieldsLimit)
          return cb();
      } else if (this._hitLimit) {
        // we may not have hit the actual limit if there are encoded bytes...
        if (i &gt; p)
          this._key += this.decoder.write(data.toString('binary', p, i));
        p = i;
        if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
          // yep, we actually did hit the limit
          this._checkingBytes = false;
          this._keyTrunc = true;
        }
      } else {
        if (p &lt; len)
          this._key += this.decoder.write(data.toString('binary', p));
        p = len;
      }
    } else {
      idxamp = undefined;
      for (i = p; i &lt; len; ++i) {
        if (!this._checkingBytes)
          ++p;
        if (data[i] === 0x26/*&amp;*/) {
          idxamp = i;
          break;
        }
        if (this._checkingBytes &amp;&amp; this._bytesVal === this.fieldSizeLimit) {
          this._hitLimit = true;
          break;
        }
        else if (this._checkingBytes)
          ++this._bytesVal;
      }

      if (idxamp !== undefined) {
        ++this._fields;
        if (idxamp &gt; p)
          this._val += this.decoder.write(data.toString('binary', p, idxamp));
        this.boy.emit('field', decodeText(this._key, 'binary', this.charset),
                               decodeText(this._val, 'binary', this.charset),
                               this._keyTrunc,
                               this._valTrunc);
        this._state = 'key';

        this._hitLimit = false;
        this._checkingBytes = true;
        this._key = '';
        this._bytesKey = 0;
        this._keyTrunc = false;
        this.decoder.reset();

        p = idxamp + 1;
        if (this._fields === this.fieldsLimit)
          return cb();
      } else if (this._hitLimit) {
        // we may not have hit the actual limit if there are encoded bytes...
        if (i &gt; p)
          this._val += this.decoder.write(data.toString('binary', p, i));
        p = i;
        if ((this._val === '' &amp;&amp; this.fieldSizeLimit === 0)
            || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {
          // yep, we actually d ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    finished = true;
    checkFinished();
  });
}

Multipart.prototype.write = function(chunk, cb) {
  var r;
  if ((r = this.parser.<span class="apidocCodeKeywordSpan">write</span>(chunk)) &amp;&amp; !this._pause)
    cb();
  else {
    this._needDrain = !r;
    this._cb = cb;
  }
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.busboy.utils" id="apidoc.module.busboy.utils">module busboy.utils</a></h1>


    <h2>
        <a href="#apidoc.element.busboy.utils.Decoder" id="apidoc.element.busboy.utils.Decoder">
        function <span class="apidocSignatureSpan">busboy.utils.</span>Decoder
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Decoder() {
  this.buffer = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.busboy.utils.basename" id="apidoc.element.busboy.utils.basename">
        function <span class="apidocSignatureSpan">busboy.utils.</span>basename
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function basename(path) {
  var f = splitPathPosix(path)[2];
  if (f === path)
    f = splitPathWindows(path)[2];
  return f;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.busboy.utils.decodeText" id="apidoc.element.busboy.utils.decodeText">
        function <span class="apidocSignatureSpan">busboy.utils.</span>decodeText
        <span class="apidocSignatureSpan">(text, textEncoding, destEncoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decodeText(text, textEncoding, destEncoding) {
  var ret;
  if (text &amp;&amp; jsencoding.encodingExists(destEncoding)) {
    try {
      ret = jsencoding.TextDecoder(destEncoding)
                      .decode(new Buffer(text, textEncoding));
    } catch(e) {}
  }
  return (typeof ret === 'string' ? ret : text);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.busboy.utils.parseParams" id="apidoc.element.busboy.utils.parseParams">
        function <span class="apidocSignatureSpan">busboy.utils.</span>parseParams
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseParams(str) {
  var res = [],
      state = 'key',
      charset = '',
      inquote = false,
      escaping = false,
      p = 0,
      tmp = '';

  for (var i = 0, len = str.length; i &lt; len; ++i) {
    if (str[i] === '\\' &amp;&amp; inquote) {
      if (escaping)
        escaping = false;
      else {
        escaping = true;
        continue;
      }
    } else if (str[i] === '"') {
      if (!escaping) {
        if (inquote) {
          inquote = false;
          state = 'key';
        } else
          inquote = true;
        continue;
      } else
        escaping = false;
    } else {
      if (escaping &amp;&amp; inquote)
        tmp += '\\';
      escaping = false;
      if ((state === 'charset' || state === 'lang') &amp;&amp; str[i] === "'") {
        if (state === 'charset') {
          state = 'lang';
          charset = tmp.substring(1);
        } else
          state = 'value';
        tmp = '';
        continue;
      } else if (state === 'key'
                 &amp;&amp; (str[i] === '*' || str[i] === '=')
                 &amp;&amp; res.length) {
        if (str[i] === '*')
          state = 'charset';
        else
          state = 'value';
        res[p] = [tmp, undefined];
        tmp = '';
        continue;
      } else if (!inquote &amp;&amp; str[i] === ';') {
        state = 'key';
        if (charset) {
          if (tmp.length) {
            tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer),
                             'binary',
                             charset);
          }
          charset = '';
        }
        if (res[p] === undefined)
          res[p] = tmp;
        else
          res[p][1] = tmp;
        tmp = '';
        ++p;
        continue;
      } else if (!inquote &amp;&amp; (str[i] === ' ' || str[i] === '\t'))
        continue;
    }
    tmp += str[i];
  }
  if (charset &amp;&amp; tmp.length) {
    tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer),
                     'binary',
                     charset);
  }

  if (res[p] === undefined) {
    if (tmp)
      res[p] = tmp;
  } else
    res[p][1] = tmp;

  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>